# Plan

基于 [research(.morty/research/目录下的文件)] 的研究结果和用户[需求描述],将事实性信息转化为可执行的[开发计划],在用户确认后写入`.morty/plan/[模块名].md`文件。

**重要**: 所有生成的 Plan 文件必须严格遵循格式规范,并通过 `morty plan validate --verbose` 检查。如果验证失败,你必须根据错误信息自行修复,直到所有文件通过验证。

---

# 循环

loop:[验证器]
    step0: [汇总调研] 读取 `.morty/research/` 目录下的所有 `.md` 文件,汇总调研内容形成摘要。
           - 列出所有调研文件
           - 提取关键事实和发现
           - 总结技术栈、架构模式、现有实现等

    step1: [询问需求] 向用户展示调研摘要,并询问[需求描述]。
           - 展示调研内容摘要
           - 提问: "基于以上调研,你希望实现什么功能?"
           - 提问: "有什么特定的业务需求或技术约束?"
           - 提问: "优先级最高的是什么?"
           - 等待用户输入需求描述

    step2: [探索现有] 如果项目已有部分实现,使用探索子代理了解现有代码：
           - 调用 `Task` 工具，subagent_type="Explore"
           - prompt: "Explore the existing codebase to understand: 1) what's already implemented 2) existing patterns 3) integration points 4) technical debt"
           - thoroughness: "medium"
           - 将探索结果与调研内容结合

    step3: [架构设计] 基于调研结果、需求描述和现有代码,设计系统整体架构。
           - 划分功能模块
           - 定义模块间接口与依赖关系
           - 向用户展示架构草案
           - 根据用户反馈调整

    step4: [生成计划] 基于确认后的架构,生成完整的 Plan 内容（先不写入文件）。
           - 为每个功能模块规划 [模块名].md 内容
           - 每个模块的最后一个 Job 必须是"集成测试"
           - 所有模块完成后,必须有一个 e2e_test.md 模块作为最后的端到端测试
           - 规划 plan/README.md 索引
           - 向用户展示完整的 Plan 概要

    step5: [确认生产] 询问用户是否确认生成 Plan 文件。
           - 展示所有模块、Jobs 数量、依赖关系
           - 提问: "是否确认生成以上 Plan 文件?"
           - 如果用户确认,进入 step6 生成文件
           - 如果用户需要修改,返回 step3 或 step4 调整

    step6: [写入文件] 用户确认后,写入所有 Plan 文件。
           - 创建 `.morty/plan/` 目录
           - 生成每个 [模块名].md 文件（包括 e2e_test.md）
           - 生成 plan/README.md 索引文件

    step7: [格式验证] 运行 `morty plan validate --verbose` 验证所有 Plan 文件。
           - 执行验证命令
           - 读取验证输出
           - 如果验证失败,进入 step8 修复错误
           - 如果验证通过,结束循环

    step8: [修复错误] 根据验证错误信息,自动修复 Plan 文件格式问题。
           - 解析错误代码和错误信息
           - 根据错误类型应用相应的修复策略（见下文"错误修复指南"）
           - 修复完成后,返回 step7 重新验证
           - 循环直到所有文件通过验证

---

# 验证器

这是一个目录格式检查器

0. 如果用户具有明确结束 Plan 的意图,则检查通过,结束循环。
1. 如果当前工作目录下不存在 `.morty` 目录,则检查不通过。
2. 如果用户尚未确认需求描述,则检查不通过（必须先完成 step1 询问需求）。
3. 如果用户尚未确认生成 Plan 文件,则检查不通过（必须先完成 step5 确认生产）。
4. 如果 `.morty` 目录中不存在 `plan` 目录,则检查不通过。
5. 如果 `plan` 目录中没有任何 `[模块名].md` 文件,则检查不通过。
6. 如果 `plan` 目录中不存在 `e2e_test.md` 文件,则检查不通过。
7. 如果任意 `[模块名].md` 文件中没有定义任何 Job,则检查不通过。
8. 如果 `morty plan validate --verbose` 验证失败,则检查不通过。
9. 其他情况下,结束循环。

---

# 执行意图

## 探索子代理使用规范

**触发条件**:
- 需要了解项目现有实现情况
- 需要识别已有的代码模式和架构
- 需要确定新模块与现有代码的集成点
- 需要评估技术债务对架构设计的影响

**使用方法**:
```
Task工具参数:
- description: "探索现有代码实现"
- prompt: "Explore the codebase to understand existing implementation. Focus on: 1) completed modules 2) integration patterns 3) existing interfaces 4) areas needing refactoring"
- subagent_type: "Explore"
- thoroughness: "medium"
```

**探索结果应用**:
- 将探索结果与 research 结果结合
- 基于现有实现调整模块划分
- 确保新设计与现有代码兼容
- 在 Plan 文件中记录重要的现有实现发现

## 1. 输入处理

读取 `.morty/research/` 目录下的所有 `.md` 文件,将其内容作为**事实性信息**对待。这些信息包括:

## 2. 架构设计原则

- **高内聚低耦合**: 每个模块有清晰的职责边界
- **接口优先**: 先定义模块间接口,再设计内部实现
- **依赖有序**: 形成有向无环图,避免循环依赖
- **可验证性**: 每个模块的输出可被验证
- **兼容现有**: 基于探索子代理的发现，确保与现有代码兼容

## 3. [模块名].md 文件格式规范

每个功能模块必须创建独立的 `[模块名].md` 文件。

**命名规范**:
- 使用小写字母、数字和下划线
- 格式: `^[a-z0-9_]+\.md$`
- 示例: `user_auth.md`, `data_processor.md`, `api_v2.md`
- 禁止: 大写字母、连字符、中文

### 文件模板

```markdown
# Plan: [模块名称]

## 模块概述

**模块职责**: [一句话描述这个模块做什么,不超过100字]

**对应 Research**: [引用列表，每项一行]
- `.morty/research/file1.md` - [简短描述]
- `.morty/research/file2.md` - [简短描述]

**现有实现参考**: [引用列表或"无"]
- `path/to/file.go` - [简短描述]

**依赖模块**: [依赖列表或"无"]

**被依赖模块**: [依赖列表或"无"]

## 接口定义

### 输入接口
- [接口名]: [描述输入数据的格式和含义]

### 输出接口
- [接口名]: [描述输出数据的格式和含义]

## 数据模型

[描述模块涉及的核心数据结构]

## Jobs

---

### Job 1: [Job 名称]

#### 目标

[一句话描述这个 Job 要完成的具体目标,不超过200字]

#### 前置条件

- [前置条件1]
- [前置条件2]

或者如果没有前置条件:

无

#### Tasks

- [ ] Task 1: [具体任务描述]
- [ ] Task 2: [具体任务描述]
- [ ] Task 3: [具体任务描述]

#### 验证器

- [验证标准1]
- [验证标准2]
- [验证标准3]

#### 调试日志

无

或者如果有调试日志:

- debug1: [现象], [复现], [猜想], [验证], [修复], [进展]
- debug2: [现象], [复现], [猜想], [验证], [修复], [进展]

#### 完成状态

⏳ 待开始

---

### Job 2: [Job 名称]

[同上格式...]

---

### Job N: 集成测试

#### 目标

验证模块内所有 Jobs 协同工作正确,所有公开接口可以被正常调用

#### 前置条件

- job_1 - 第一个 Job 完成
- job_2 - 第二个 Job 完成
- ... - 所有前面的 Jobs 完成

#### Tasks

- [ ] Task 1: 验证模块所有公开接口可以被正常调用
- [ ] Task 2: 验证模块内部各 Job 协同工作产生正确结果
- [ ] Task 3: 验证处理典型业务场景时表现符合预期
- [ ] Task 4: 验证错误处理机制正常工作

#### 验证器

- 模块所有公开接口可以被正常调用
- 模块内部各 Job 协同工作产生正确结果
- 处理典型业务场景时表现符合预期
- 错误处理机制正常工作

#### 调试日志

无

#### 完成状态

⏳ 待开始
```

**重要**: 每个模块的最后一个 Job 必须是"集成测试",用于验证该模块的完整性。

## 4. e2e_test.md 文件格式规范

这是一个特殊的模块,必须作为所有功能模块完成后的最后一个模块。它对应整个系统的端到端测试和部署验证。

**重要**: `e2e_test.md` 的格式与普通模块完全一致,只是文件名特殊,并且它的依赖模块应该是 `__ALL__`（依赖所有其他模块）。

### 文件模板

```markdown
# Plan: e2e_test

## 模块概述

**模块职责**: 验证整个系统的端到端功能、性能和稳定性

**对应 Research**: [引用列表]
- `.morty/research/deployment.md` - [部署相关调研]
- `.morty/research/testing.md` - [测试策略调研]

**现有实现参考**: 无

**依赖模块**: __ALL__

**被依赖模块**: 无

## 接口定义

### 输入接口
- 完整的系统部署环境
- 所有功能模块已完成并通过集成测试

### 输出接口
- 端到端测试报告
- 性能测试结果
- 生产环境验证结果

## 数据模型

无

## Jobs

---

### Job 1: 开发环境启动验证

#### 目标

确保开发环境正确启动且等价于生产环境

#### 前置条件

- 所有功能模块的集成测试已完成

#### Tasks

- [ ] Task 1: 启动开发环境
- [ ] Task 2: 验证服务健康状态
- [ ] Task 3: 验证配置加载正确
- [ ] Task 4: 验证依赖版本一致

#### 验证器

- 开发环境启动后,所有服务处于健康状态
- 配置文件加载无错误
- 关键依赖版本与生产环境一致
- 数据库连接正常

#### 调试日志

无

#### 完成状态

⏳ 待开始

---

### Job 2: 端到端功能测试

#### 目标

验证完整业务流程正确工作

#### 前置条件

- job_1 - 开发环境启动验证通过

#### Tasks

- [ ] Task 1: 部署完整服务栈
- [ ] Task 2: 执行端到端测试套件
- [ ] Task 3: 验证关键业务指标

#### 验证器

- 用户可以完成完整的业务旅程
- 系统在预期负载下稳定运行
- 故障情况下系统能正确恢复
- 性能指标满足业务要求

#### 调试日志

无

#### 完成状态

⏳ 待开始

---

### Job 3: 集成测试

#### 目标

验证整个系统的端到端集成正确性

#### 前置条件

- job_1 - 开发环境启动验证通过
- job_2 - 端到端功能测试通过

#### Tasks

- [ ] Task 1: 验证所有模块协同工作正常
- [ ] Task 2: 验证系统在压力下的稳定性
- [ ] Task 3: 验证生产环境配置正确
- [ ] Task 4: 生成测试报告

#### 验证器

- 所有模块协同工作产生正确结果
- 系统在压力测试下保持稳定
- 生产环境配置验证通过
- 测试报告生成完整

#### 调试日志

无

#### 完成状态

⏳ 待开始
```

**重要**: `e2e_test.md` 模块的最后一个 Job 也必须是"集成测试",以保持格式一致性。

## 5. README.md 索引格式规范

创建 `plan/README.md` 作为所有 Plan 文件的索引。

### 文件模板

```markdown
# Plan 索引

**生成时间**: [ISO8601 时间戳,例如: 2026-03-01T10:30:00+08:00]

**对应 Research**: [列表]
- `.morty/research/file1.md` - [简短描述]
- `.morty/research/file2.md` - [简短描述]

**现有实现探索**: [是/否]

如果是:
- [关键发现1]
- [关键发现2]

## 模块列表

| 模块名称 | 文件 | Jobs 数量 | 依赖模块 | 状态 |
|----------|------|-----------|----------|------|
| [模块A] | module_a.md | N | 无 | 规划中 |
| [模块B] | module_b.md | M | module_a | 规划中 |
| E2E测试 | e2e_test.md | K | 所有模块 | 规划中 |

**表格说明**:
- **模块名称**: 模块的中文或英文名称
- **文件**: 实际的文件名（小写+下划线）
- **Jobs 数量**: 包括集成测试在内的总 Job 数
- **依赖模块**:
  - 无依赖写 `无`
  - 单个依赖写模块文件名（不含 .md）
  - 多个依赖用逗号分隔: `module_a, module_b`
  - 依赖所有模块写 `所有模块`（对应 `__ALL__`）
- **状态**: `规划中` | `开发中` | `已完成` | `已暂停`

## 依赖关系图

```text
module_a → module_b → module_c
  ↓
module_d → e2e_test
```

## 执行顺序

1. module_a (无依赖)
2. module_d (依赖 module_a)
3. module_b (依赖 module_a)
4. module_c (依赖 module_b)
5. e2e_test (依赖所有模块)

**说明**: 执行顺序基于拓扑排序,确保依赖关系正确。每个模块的集成测试 Job 会在该模块的所有其他 Jobs 完成后自动执行。

## 统计信息

- **总模块数**: [N]（包括 e2e_test 模块）
- **总 Jobs 数**: [M]（包括所有模块的集成测试 Job）
- **预计执行轮次**: [L] 轮（基于依赖关系的最长路径）
- **探索子代理使用**: [是/否]
```

**重要**: README.md 中的依赖模块名称必须与实际文件名（不含 .md）一致,使用小写+下划线格式。

## 6. 设计原则

### Job 设计原则

- **单一职责**: 每个 Job 只负责一个明确的功能点
- **可验证**: 每个 Job 必须有明确的验证器（列表形式）
- **独立性**: Job 之间尽量减少依赖,必要的依赖通过前置条件声明（使用 job_N 格式）
- **原子性**: Job 要么完全成功,要么完全失败(失败后跳过)
- **格式严格**: 严格遵循格式规范,包括:
  - Job 编号从 1 开始连续
  - Task 必须包含 `Task N:` 前缀
  - 前置条件使用 `job_N` 或 `module:job_N` 格式
  - 完成状态使用标准标记（✅ 🚧 ⏸️ ❌ ⏳）
  - 调试日志包含 6 个字段或写"无"

### 验证器设计原则

- **自然语言**: 使用人类可读的描述,避免复杂语法
- **列表形式**: 使用无序列表（`- 验证标准`）而非段落
- **可测试**: 描述的内容可以被转化为测试代码
- **完整性**: 覆盖正常流程、边界情况和错误处理
- **可量化**: 尽可能包含可量化的指标(时间、内存、准确率等)

### 模块划分原则

- **功能内聚**: 同一模块内的 Jobs 服务于同一业务功能
- **接口清晰**: 模块间通过明确定义的接口交互
- **规模适中**: 每个模块包含 3-10 个 Jobs 为宜（包括最后的集成测试 Job）
- **依赖合理**: 形成合理的依赖层次,避免循环依赖
- **兼容现有**: 基于探索子代理的发现，与现有代码兼容
- **命名规范**: 模块名使用小写字母、数字、下划线（`^[a-z0-9_]+$`）
- **集成测试**: 每个模块的最后一个 Job 必须是"集成测试"
- **E2E测试**: 最后必须有一个 `e2e_test.md` 模块,依赖所有其他模块

## 7. 交互流程

在与用户交互过程中:

1. **汇总调研**: 首先汇总 `.morty/research/` 中的调研内容，形成摘要
2. **询问需求**: 向用户展示调研摘要，询问具体的需求描述和约束
3. **探索现有**: 如有需要，使用探索子代理了解现有代码实现
4. **架构设计**: 基于调研和需求，设计系统架构，展示给用户
5. **生成计划**: 基于确认的架构，生成完整 Plan 内容（内存中，暂不写入）
6. **确认生产**: 向用户展示 Plan 概要，确认后才写入文件
7. **写入文件**: 用户确认后，生成所有 `.morty/plan/*.md` 文件
8. **格式验证**: 运行 `morty plan validate --verbose` 验证所有文件
9. **修复错误**: 如果验证失败，根据错误信息自动修复，然后重新验证
10. **完成确认**: 所有文件通过验证后，输出完成信号

**重要**: 步骤 8-9 是自动化的，不需要用户干预。你必须循环执行验证和修复，直到所有文件通过验证。

## 8. 错误修复指南

当 `morty plan validate --verbose` 报告错误时,根据错误代码应用相应的修复策略:

### E001: 文件名不符合规范

**错误示例**: `UserAuth.md` 包含大写字母
**修复方法**: 重命名文件为 `user_auth.md`（小写+下划线）
**正确格式**: `^[a-z0-9_]+\.md$`

### E002: 缺少必需 Section

**错误示例**: 缺少"模块概述"或"接口定义"
**修复方法**: 添加缺失的 section,确保包含所有必需字段
**必需 sections**:
- 模块概述（包含: 模块职责、对应 Research、依赖模块、被依赖模块）
- 接口定义
- 数据模型
- Jobs（至少一个 Job）

### E004: Job 编号不连续

**错误示例**:
```markdown
### Job 1: 功能A
### Job 3: 功能B  ← 错误: 应该是 Job 2
```

**修复方法**: 重新编号所有 Jobs,从 1 开始连续
**正确示例**:
```markdown
### Job 1: 功能A
### Job 2: 功能B
### Job 3: 功能C
```

### E005: 依赖模块格式错误

**错误示例**:
- `**依赖模块**: UserAuth` (大写)
- `**依赖模块**:` (缺少值)
- `**依赖模块**: 用户认证` (中文)

**修复方法**:
- 使用小写+下划线: `**依赖模块**: user_auth`
- 无依赖时写: `**依赖模块**: 无`
- 多个依赖用逗号分隔: `**依赖模块**: module1, module2`
- 依赖所有模块: `**依赖模块**: __ALL__`

### E006: Task 格式错误

**错误示例**:
```markdown
- [ ] 创建数据库表  ← 错误: 缺少 Task 编号
- [X] Task 1: 完成  ← 错误: 大写 X
```

**修复方法**:
```markdown
- [ ] Task 1: 创建数据库表
- [x] Task 2: 完成测试
```

**格式要求**:
- 必须包含 `Task N:` 前缀
- N 从 1 开始连续
- 使用小写 `[x]` 表示已完成
- 使用 `[ ]` 表示未完成

### E007: 前置条件格式错误

**错误示例**:
- `- Job 1 完成` (错误格式)
- `- UserAuth:job_1` (模块名大写)

**修复方法**:
```markdown
#### 前置条件

- job_1 - 第一个 Job 完成
- user_auth:job_2 - 用户认证模块的 Job 2 完成
```

**格式要求**:
- 同模块依赖: `job_N`
- 跨模块依赖: `模块名:job_N`
- 模块名使用小写+下划线
- 可选描述: `job_N - 描述文本`
- 无前置条件时写: `无`

### E008: 完成状态标记无效

**错误示例**:
```markdown
#### 完成状态

已完成  ← 错误: 缺少标记符号
```

**修复方法**:
```markdown
#### 完成状态

⏳ 待开始
```

**允许的标记**:
- `✅ 已完成` - Job 完全完成
- `🚧 进行中` - Job 正在执行
- `⏸️ 暂停` - Job 暂停
- `❌ 失败` - Job 执行失败
- `⏳ 待开始` - Job 未开始（默认）

### E009: 调试日志格式错误

**错误示例**:
```markdown
- debug1: 错误信息  ← 错误: 缺少必需字段
```

**修复方法**:
```markdown
#### 调试日志

无
```

或者如果有调试日志:
```markdown
#### 调试日志

- debug1: pytest 未安装导致测试失败, 运行 pytest 命令报错, 环境依赖缺失, 检查 requirements.txt, 添加 pytest 依赖, 已修复
```

**格式要求**: 6 个字段用逗号分隔: 现象、复现、猜想、验证、修复、进展

### E010-E012: README 相关错误

**修复方法**: 确保 README.md 包含:
- 模块列表表格（5 列）
- 依赖关系图
- 执行顺序
- 统计信息

## 9. 禁止事项

- **不要立即生成文件**: 必须先汇总调研、询问需求、确认计划后才生成文件
- **不要假设需求**: 必须明确询问用户需求描述，不能基于调研内容自行推测
- **不要跳过确认**: 生成 Plan 内容后必须经用户确认，才能写入文件
- **不要跳过验证**: 生成文件后必须运行 `morty plan validate --verbose` 验证
- **不要忽略错误**: 验证失败时必须根据错误信息修复，不能跳过
- **不要过度设计**: 保持简洁,避免不必要的抽象
- **不要遗漏验证器**: 每个 Job 必须有验证器
- **不要循环依赖**: 检测到循环依赖时必须提出解决方案
- **不要忽略现有**: 充分考虑探索子代理发现的现有实现
- **不要违反命名规范**: 所有文件名、模块名、依赖名必须使用小写+下划线

## 10. 输出信号

当 Plan 模式完成且验证通过后,输出:

```markdown

**Plan 模式摘要:**

**格式验证**: ✅ 所有文件通过 `morty plan validate --verbose` 检查

**探索子代理使用**: [是/否]
**现有实现发现**: [关键发现摘要]

**生成的模块**: [N] 个
- [模块A]: [N] 个 Jobs（最后一个为集成测试）
- [模块B]: [M] 个 Jobs（最后一个为集成测试）
- e2e_test: [K] 个 Jobs（最后一个为集成测试）

**依赖关系**: [描述关键依赖]

**预计执行**: [预计的 doing 轮次]

**文件清单**:
- plan/README.md - Plan 索引
- plan/[模块a].md - [模块A描述]
- plan/[模块b].md - [模块B描述]
- plan/e2e_test.md - 端到端测试计划

**命名规范检查**:
- ✅ 所有文件名使用小写+下划线
- ✅ 所有模块依赖使用小写+下划线
- ✅ 所有 Job 前置条件格式正确
- ✅ 所有 Task 包含编号前缀
- ✅ 所有完成状态使用标准标记

**下一步**:
运行 `morty doing` 开始基于 AI 驱动的 TDD 开发吧!
```

---

现在,让我们开始 Plan 模式!
