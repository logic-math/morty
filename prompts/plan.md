# Plan

基于 [research(.morty/research/目录下的文件)] 的研究结果,将事实性信息转化为可执行的[开发计划],写入`.morty/plan/[模块名].md`并且最后追加一个`[生产测试].md`文件。

---

# 循环

loop:[验证器]
    step0: 理解 [research] 的研究结果,提取所有事实性信息作为规划基础。
    step1: [架构设计] 基于事实性信息,设计系统整体架构,划分功能模块,定义模块间接口与依赖关系;
           - 如果用户对架构设计有明确意见,则遵从用户的想法进行修改。
           - 如果在架构设计需要用户决策,则给用户提供选项,让用户选择。
    step2: [模块规划] 为每个功能模块创建 [模块名].md 文件,包含:
           - 模块概述与接口定义
           - 数据模型设计
           - Jobs (Loop 块) 列表,每个 Job 包含:
             * 目标描述
             * 前置条件
             * Tasks (Todo 列表)
             * 验证器 (自然语言描述验收标准)
             * 调试日志
           - 模块级集成测试验证器
    step3: [生产测试规划] 创建 [生产测试].md 文件,包含:
           - 部署架构 (开发/生产环境同构策略)
           - 环境一致性保障措施
           - 端到端测试 Job (验证完整业务流程)
    step4: [索引生成] 创建 plan/README.md 索引文件,汇总所有模块和依赖关系。
    step5: [验证确认] 向用户展示规划概要,确认模块划分和 Job 设计是否合理,根据反馈调整。

---

# 验证器

这是一个目录格式检查器

0. 如果用户具有明确结束 Plan 的意图,则检查通过,结束循环。
1. 如果当前工作目录下不存在 `.morty` 目录,则检查不通过。
2. 如果 `.morty` 目录中不存在 `plan` 目录,则检查不通过。
3. 如果 `plan` 目录中没有任何 `[模块名].md` 文件,则检查不通过。
4. 如果 `plan` 目录中不存在 `[生产测试].md` 文件,则检查不通过。
5. 如果任意 `[模块名].md` 文件中没有定义任何 Job,则检查不通过。
6. 其他情况下,结束循环。

---

# 执行意图

## 1. 输入处理
读取 `.morty/research/` 目录下的所有 `.md` 文件,将其内容作为**事实性信息**对待。这些信息包括:

## 2. 架构设计原则

- **高内聚低耦合**: 每个模块有清晰的职责边界
- **接口优先**: 先定义模块间接口,再设计内部实现
- **依赖有序**: 形成有向无环图,避免循环依赖
- **可验证性**: 每个模块的输出可被验证

## 3. [模块名].md 文件格式规范

每个功能模块必须创建独立的 `[模块名].md` 文件,文件命名使用小写字母和下划线,例如: `user_auth.md`, `data_processor.md`。

### 文件模板

```markdown
# Plan: [模块名称]

## 模块概述

**模块职责**: [一句话描述这个模块做什么]

**对应 Research**: [引用 .morty/research/ 中的相关发现]

**依赖模块**: [依赖的其他模块,没有则写"无"]

**被依赖模块**: [依赖此模块的其他模块,没有则写"无"]

## 接口定义

### 输入接口
- [接口名]: [描述输入数据的格式和含义]

### 输出接口
- [接口名]: [描述输出数据的格式和含义]

## 数据模型

[描述模块涉及的核心数据结构]

## Jobs (Loop 块列表)

---

### Job 1: [Job 名称]

**目标**: [这个 Job 要完成的具体目标,一句话描述]

**前置条件**:
- [前置 Job 或其他条件]

**Tasks (Todo 列表)**:
- [ ] Task 1: [具体任务描述]
- [ ] Task 2: [具体任务描述]
- [ ] Task 3: [具体任务描述]

**验证器**:
[使用自然语言描述验收标准,例如:]
[当输入 XXX 时,应该输出 YYY]
[处理 ZZZ 边界情况时不应该抛出异常]
[响应时间应该在 100ms 以内]
[内存使用不应超过 10MB]

**调试日志**:
- 如果验证失败,记录debug日志到此处
  - debug1:错误现象/信息,复现方法,猜想原因(按证据置信度排序),验证todo, 修复方法,修复进展。
  - debug2:...

---

### Job 2: [Job 名称]

[同上格式...]

---

## 集成测试

**触发条件**: 模块内所有 Jobs 完成

**验证器**:
[使用自然语言描述模块级集成测试标准,例如:]
[模块所有公开接口可以被正常调用]
[模块内部各 Job 协同工作产生正确结果]
[处理典型业务场景时表现符合预期]
[错误处理机制正常工作]
```

## 4. [生产测试].md 文件格式规范

这是一个特殊的 Plan 文件,对应整个系统的端到端测试和部署规划。

### 文件模板

```markdown
# Plan: [生产测试]

## 部署架构

### 目标环境
- **开发环境**: [描述开发环境要求]
- **生产环境**: [描述生产环境要求]

### 环境同构策略
[描述如何确保开发环境和生产环境一致,例如:]
- 使用 Docker 容器化部署
- 配置文件模板化管理
- 依赖版本锁定机制
- 数据库迁移脚本版本控制

### 部署流程
1. [构建步骤]
2. [测试步骤]
3. [打包步骤]
4. [部署步骤]

## Jobs

---

### Job: 开发环境启动验证

**目标**: 确保开发环境正确启动且等价于生产环境

**前置条件**:
- 所有功能模块开发完成

**Tasks (Todo 列表)**:
- [ ] 启动开发环境
- [ ] 验证服务健康状态
- [ ] 验证配置加载正确
- [ ] 验证依赖版本一致

**验证器**:
[使用自然语言描述环境验证标准,例如:]
[开发环境启动后,所有服务处于健康状态]
[配置文件加载无错误]
[关键依赖版本与生产环境一致]
[数据库连接正常]

**调试日志**:
- 如果验证失败,记录debug日志到此处
  - debug1:错误现象/信息,复现方法,猜想原因(按证据置信度排序),验证todo, 修复方法,修复进展。
  - debug2:...

---

### Job: 端到端功能测试

**目标**: 验证完整业务流程正确工作

**前置条件**:
- 开发环境启动验证通过

**Tasks (Todo 列表)**:
- [ ] 部署完整服务栈
- [ ] 执行端到端测试套件
- [ ] 验证关键业务指标

**验证器**:
[使用自然语言描述端到端测试标准,例如:]
[用户可以完成完整的业务旅程]
[系统在预期负载下稳定运行]
[故障情况下系统能正确恢复]
[性能指标满足业务要求]

**调试日志**:
- 如果验证失败,记录debug日志到此处
  - debug1:错误现象/信息,复现方法,猜想原因(按证据置信度排序),验证todo, 修复方法,修复进展。
  - debug2:...
```

## 5. README.md 索引格式规范

创建 `plan/README.md` 作为所有 Plan 文件的索引。

### 文件模板

```markdown
# Plan 索引

**生成时间**: [ISO8601 时间戳]

**对应 Research**: [.morty/research/ 下的文件列表]

## 模块列表

| 模块名称 | 文件 | Jobs 数量 | 依赖模块 | 状态 |
|----------|------|-----------|----------|------|
| [模块A] | [模块a].md | N | [依赖] | 规划中 |
| [模块B] | [模块b].md | M | [依赖] | 规划中 |

## 依赖关系图

```text
[模块A] → [模块B] → [模块C]
  ↓
[模块D]
```

## 执行顺序

1. [模块A] (无依赖)
2. [模块D] (依赖模块A)
3. [模块B] (依赖模块A)
4. [模块C] (依赖模块B)
5. [生产测试] (所有模块完成后)

## 统计信息

- 总模块数: [N]
- 总 Jobs 数: [M]
- 预计执行轮次: [根据依赖关系计算]
```

## 6. 设计原则

### Job 设计原则

- **单一职责**: 每个 Job 只负责一个明确的功能点
- **可验证**: 每个 Job 必须有明确的验证器
- **独立性**: Job 之间尽量减少依赖,必要的依赖通过前置条件声明
- **原子性**: Job 要么完全成功,要么完全失败(失败后跳过)

### 验证器设计原则

- **自然语言**: 使用人类可读的描述,避免复杂语法
- **可测试**: 描述的内容可以被转化为测试代码
- **完整性**: 覆盖正常流程、边界情况和错误处理
- **可量化**: 尽可能包含可量化的指标(时间、内存、准确率等)

### 模块划分原则

- **功能内聚**: 同一模块内的 Jobs 服务于同一业务功能
- **接口清晰**: 模块间通过明确定义的接口交互
- **规模适中**: 每个模块包含 3-10 个 Jobs 为宜
- **依赖合理**: 形成合理的依赖层次,避免循环依赖

## 7. 交互流程

在与用户交互过程中:

1. **展示架构**: 先展示设计的模块划分和依赖关系
2. **确认接口**: 确认模块间接口定义是否合理
3. **讨论验证器**: 讨论关键 Job 的验证器是否完整
4. **调整优化**: 根据用户反馈调整 Plan
5. **生成文件**: 用户确认后生成所有 Plan 文件

## 8. 禁止事项

- **不要假设**: 基于 Research 的事实,不要引入未经验证的假设
- **不要过度设计**: 保持简洁,避免不必要的抽象
- **不要遗漏验证**: 每个 Job 必须有验证器
- **不要循环依赖**: 检测到循环依赖时必须提出解决方案

## 9. 输出信号

当 Plan 模式完成且验证通过后,输出:

```markdown
<!-- PLAN_MODE_COMPLETE -->

**Plan 模式摘要:**

**生成的模块**: [N] 个
- [模块A]: [N] 个 Jobs
- [模块B]: [M] 个 Jobs
...

**依赖关系**: [描述关键依赖]

**预计执行**: [预计的 doing 轮次]

**文件清单**:
- plan/README.md - Plan 索引
- plan/[模块A].md - [模块A描述]
- plan/[模块B].md - [模块B描述]
- plan/[生产测试].md - 端到端测试计划

**下一步**:
运行 `morty doing` 开始分层 TDD 开发
```

---

现在,让我们开始 Plan 模式!
