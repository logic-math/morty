# Plan

基于 [research(.morty/research/目录下的文件)] 的研究结果和用户[需求描述],将事实性信息转化为可执行的[开发计划],在用户确认后写入`.morty/plan/[模块名].md`并且最后追加一个`[生产测试].md`文件。

---

# 循环

loop:[验证器]
    step0: [汇总调研] 读取 `.morty/research/` 目录下的所有 `.md` 文件,汇总调研内容形成摘要。
           - 列出所有调研文件
           - 提取关键事实和发现
           - 总结技术栈、架构模式、现有实现等

    step1: [询问需求] 向用户展示调研摘要,并询问[需求描述]。
           - 展示调研内容摘要
           - 提问: "基于以上调研,你希望实现什么功能?"
           - 提问: "有什么特定的业务需求或技术约束?"
           - 提问: "优先级最高的是什么?"
           - 等待用户输入需求描述

    step2: [探索现有] 如果项目已有部分实现,使用探索子代理了解现有代码：
           - 调用 `Task` 工具，subagent_type="Explore"
           - prompt: "Explore the existing codebase to understand: 1) what's already implemented 2) existing patterns 3) integration points 4) technical debt"
           - thoroughness: "medium"
           - 将探索结果与调研内容结合

    step3: [架构设计] 基于调研结果、需求描述和现有代码,设计系统整体架构。
           - 划分功能模块
           - 定义模块间接口与依赖关系
           - 向用户展示架构草案
           - 根据用户反馈调整

    step4: [生成计划] 基于确认后的架构,生成完整的 Plan 内容（先不写入文件）。
           - 为每个功能模块规划 [模块名].md 内容
           - 规划 [生产测试].md 内容
           - 规划 plan/README.md 索引
           - 向用户展示完整的 Plan 概要

    step5: [确认生产] 询问用户是否确认生成 Plan 文件。
           - 展示所有模块、Jobs 数量、依赖关系
           - 提问: "是否确认生成以上 Plan 文件?"
           - 如果用户确认,进入 step6 生成文件
           - 如果用户需要修改,返回 step3 或 step4 调整

    step6: [写入文件] 用户确认后,写入所有 Plan 文件。
           - 创建 `.morty/plan/` 目录
           - 生成每个 [模块名].md 文件
           - 生成 [生产测试].md 文件
           - 生成 plan/README.md 索引文件

---

# 验证器

这是一个目录格式检查器

0. 如果用户具有明确结束 Plan 的意图,则检查通过,结束循环。
1. 如果当前工作目录下不存在 `.morty` 目录,则检查不通过。
2. 如果用户尚未确认需求描述,则检查不通过（必须先完成 step1 询问需求）。
3. 如果用户尚未确认生成 Plan 文件,则检查不通过（必须先完成 step5 确认生产）。
4. 如果 `.morty` 目录中不存在 `plan` 目录,则检查不通过。
5. 如果 `plan` 目录中没有任何 `[模块名].md` 文件,则检查不通过。
6. 如果 `plan` 目录中不存在 `[生产测试].md` 文件,则检查不通过。
7. 如果任意 `[模块名].md` 文件中没有定义任何 Job,则检查不通过。
8. 其他情况下,结束循环。

---

# 执行意图

## 探索子代理使用规范

**触发条件**:
- 需要了解项目现有实现情况
- 需要识别已有的代码模式和架构
- 需要确定新模块与现有代码的集成点
- 需要评估技术债务对架构设计的影响

**使用方法**:
```
Task工具参数:
- description: "探索现有代码实现"
- prompt: "Explore the codebase to understand existing implementation. Focus on: 1) completed modules 2) integration patterns 3) existing interfaces 4) areas needing refactoring"
- subagent_type: "Explore"
- thoroughness: "medium"
```

**探索结果应用**:
- 将探索结果与 research 结果结合
- 基于现有实现调整模块划分
- 确保新设计与现有代码兼容
- 在 Plan 文件中记录重要的现有实现发现

## 1. 输入处理

读取 `.morty/research/` 目录下的所有 `.md` 文件,将其内容作为**事实性信息**对待。这些信息包括:

## 2. 架构设计原则

- **高内聚低耦合**: 每个模块有清晰的职责边界
- **接口优先**: 先定义模块间接口,再设计内部实现
- **依赖有序**: 形成有向无环图,避免循环依赖
- **可验证性**: 每个模块的输出可被验证
- **兼容现有**: 基于探索子代理的发现，确保与现有代码兼容

## 3. [模块名].md 文件格式规范

每个功能模块必须创建独立的 `[模块名].md` 文件,文件命名使用小写字母和下划线,例如: `user_auth.md`, `data_processor.md`。

### 文件模板

```markdown
# Plan: [模块名称]

## 模块概述

**模块职责**: [一句话描述这个模块做什么]

**对应 Research**: [引用 .morty/research/ 中的相关发现]

**现有实现参考**: [如使用探索子代理，引用发现的现有实现]

**依赖模块**: [依赖的其他模块,没有则写"无"]

**被依赖模块**: [依赖此模块的其他模块,没有则写"无"]

## 接口定义

### 输入接口
- [接口名]: [描述输入数据的格式和含义]

### 输出接口
- [接口名]: [描述输出数据的格式和含义]

## 数据模型

[描述模块涉及的核心数据结构]

## Jobs (Loop 块列表)

---

### Job 1: [Job 名称]

**目标**: [这个 Job 要完成的具体目标,一句话描述]

**前置条件**:
- [前置 Job 或其他条件]

**Tasks (Todo 列表)**:
- [ ] Task 1: [具体任务描述]
- [ ] Task 2: [具体任务描述]
- [ ] Task 3: [具体任务描述]

**验证器**:
[使用自然语言描述验收标准,例如:]
[当输入 XXX 时,应该输出 YYY]
[处理 ZZZ 边界情况时不应该抛出异常]
[响应时间应该在 100ms 以内]
[内存使用不应超过 10MB]

**调试日志**:
- 如果验证失败,记录debug日志到此处
  - debug1:错误现象/信息,复现方法,猜想原因(按证据置信度排序),验证todo, 修复方法,修复进展。
  - debug2:...

---

### Job 2: [Job 名称]

[同上格式...]

---

## 集成测试

**触发条件**: 模块内所有 Jobs 完成

**验证器**:
[使用自然语言描述模块级集成测试标准,例如:]
[模块所有公开接口可以被正常调用]
[模块内部各 Job 协同工作产生正确结果]
[处理典型业务场景时表现符合预期]
[错误处理机制正常工作]
```

## 4. [生产测试].md 文件格式规范

这是一个特殊的 Plan 文件,对应整个系统的端到端测试和部署规划。

### 文件模板

```markdown
# Plan: [生产测试]

## 部署架构

### 目标环境
- **开发环境**: [描述开发环境要求]
- **生产环境**: [描述生产环境要求]

### 环境同构策略
[描述如何确保开发环境和生产环境一致,例如:]
- 使用 Docker 容器化部署
- 配置文件模板化管理
- 依赖版本锁定机制
- 数据库迁移脚本版本控制

### 部署流程
1. [构建步骤]
2. [测试步骤]
3. [打包步骤]
4. [部署步骤]

## Jobs

---

### Job: 开发环境启动验证

**目标**: 确保开发环境正确启动且等价于生产环境

**前置条件**:
- 所有功能模块开发完成

**Tasks (Todo 列表)**:
- [ ] 启动开发环境
- [ ] 验证服务健康状态
- [ ] 验证配置加载正确
- [ ] 验证依赖版本一致

**验证器**:
[使用自然语言描述环境验证标准,例如:]
[开发环境启动后,所有服务处于健康状态]
[配置文件加载无错误]
[关键依赖版本与生产环境一致]
[数据库连接正常]

**调试日志**:
- 如果验证失败,记录debug日志到此处
  - debug1:错误现象/信息,复现方法,猜想原因(按证据置信度排序),验证todo, 修复方法,修复进展。
  - debug2:...

---

### Job: 端到端功能测试

**目标**: 验证完整业务流程正确工作

**前置条件**:
- 开发环境启动验证通过

**Tasks (Todo 列表)**:
- [ ] 部署完整服务栈
- [ ] 执行端到端测试套件
- [ ] 验证关键业务指标

**验证器**:
[使用自然语言描述端到端测试标准,例如:]
[用户可以完成完整的业务旅程]
[系统在预期负载下稳定运行]
[故障情况下系统能正确恢复]
[性能指标满足业务要求]

**调试日志**:
- 如果验证失败,记录debug日志到此处
  - debug1:错误现象/信息,复现方法,猜想原因(按证据置信度排序),验证todo, 修复方法,修复进展。
  - debug2:...
```

## 5. README.md 索引格式规范

创建 `plan/README.md` 作为所有 Plan 文件的索引。

### 文件模板

```markdown
# Plan 索引

**生成时间**: [ISO8601 时间戳]

**对应 Research**: [.morty/research/ 下的文件列表]

**现有实现探索**: [如使用探索子代理，总结关键发现]

## 模块列表

| 模块名称 | 文件 | Jobs 数量 | 依赖模块 | 状态 |
|----------|------|-----------|----------|------|
| [模块A] | [模块a].md | N | [依赖] | 规划中 |
| [模块B] | [模块b].md | M | [依赖] | 规划中 |

## 依赖关系图

```text
[模块A] → [模块B] → [模块C]
  ↓
[模块D]
```

## 执行顺序

1. [模块A] (无依赖)
2. [模块D] (依赖模块A)
3. [模块B] (依赖模块A)
4. [模块C] (依赖模块B)
5. [生产测试] (所有模块完成后)

## 统计信息

- 总模块数: [N]
- 总 Jobs 数: [M]
- 预计执行轮次: [根据依赖关系计算]
- 探索子代理使用: [是/否]
```

## 6. 设计原则

### Job 设计原则

- **单一职责**: 每个 Job 只负责一个明确的功能点
- **可验证**: 每个 Job 必须有明确的验证器
- **独立性**: Job 之间尽量减少依赖,必要的依赖通过前置条件声明
- **原子性**: Job 要么完全成功,要么完全失败(失败后跳过)

### 验证器设计原则

- **自然语言**: 使用人类可读的描述,避免复杂语法
- **可测试**: 描述的内容可以被转化为测试代码
- **完整性**: 覆盖正常流程、边界情况和错误处理
- **可量化**: 尽可能包含可量化的指标(时间、内存、准确率等)

### 模块划分原则

- **功能内聚**: 同一模块内的 Jobs 服务于同一业务功能
- **接口清晰**: 模块间通过明确定义的接口交互
- **规模适中**: 每个模块包含 3-10 个 Jobs 为宜
- **依赖合理**: 形成合理的依赖层次,避免循环依赖
- **兼容现有**: 基于探索子代理的发现，与现有代码兼容

## 7. 交互流程

在与用户交互过程中:

1. **汇总调研**: 首先汇总 `.morty/research/` 中的调研内容，形成摘要
2. **询问需求**: 向用户展示调研摘要，询问具体的需求描述和约束
3. **探索现有**: 如有需要，使用探索子代理了解现有代码实现
4. **架构设计**: 基于调研和需求，设计系统架构，展示给用户
5. **生成计划**: 基于确认的架构，生成完整 Plan 内容（内存中，暂不写入）
6. **确认生产**: 向用户展示 Plan 概要，确认后才写入文件
7. **写入文件**: 用户确认后，生成所有 `.morty/plan/*.md` 文件

## 8. 禁止事项

- **不要立即生成文件**: 必须先汇总调研、询问需求、确认计划后才生成文件
- **不要假设需求**: 必须明确询问用户需求描述，不能基于调研内容自行推测
- **不要跳过确认**: 生成 Plan 内容后必须经用户确认，才能写入文件
- **不要过度设计**: 保持简洁,避免不必要的抽象
- **不要遗漏验证**: 每个 Job 必须有验证器
- **不要循环依赖**: 检测到循环依赖时必须提出解决方案
- **不要忽略现有**: 充分考虑探索子代理发现的现有实现

## 9. 输出信号

当 Plan 模式完成且验证通过后,输出:

```markdown
<!-- PLAN_MODE_COMPLETE -->

**Plan 模式摘要:**

**探索子代理使用**: [是/否]
**现有实现发现**: [关键发现摘要]

**生成的模块**: [N] 个
- [模块A]: [N] 个 Jobs
- [模块B]: [M] 个 Jobs
...

**依赖关系**: [描述关键依赖]

**预计执行**: [预计的 doing 轮次]

**文件清单**:
- plan/README.md - Plan 索引
- plan/[模块A].md - [模块A描述]
- plan/[模块B].md - [模块B描述]
- plan/[生产测试].md - 端到端测试计划

**下一步**:
运行 `morty doing` 开始分层 TDD 开发
```

---

现在,让我们开始 Plan 模式!
