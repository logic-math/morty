#!/bin/bash
# Morty - 上下文优先的AI Coding Agent 编排框架
# 统一命令接口 - 主命令脚本
#
# 文件名: morty
# 位置: $MORTY_HOME/morty 或 /usr/local/bin/morty

set -o pipefail

# ============================================================================
# 全局变量
# ============================================================================

VERSION="2.0.0"
MORTY_HOME="${MORTY_HOME:-$HOME/.morty}"
MORTY_PROJECT_ROOT="${MORTY_PROJECT_ROOT:-}"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# 命令注册表 (关联数组)
declare -A CLI_COMMAND_HANDLERS
declare -A CLI_COMMAND_DESCRIPTIONS
declare -A CLI_COMMAND_OPTIONS
declare -a CLI_COMMAND_ORDER

# 参数解析结果
declare -a CLI_POSITIONAL_ARGS
declare -A CLI_OPTION_ARGS
declare -a CLI_OPTION_FLAGS

# 解析状态
declare -i CLI_PARSE_ERROR=0

# ============================================================================
# 错误处理和日志
# ============================================================================

# 显示错误信息并退出
# Usage: cli_error <message> [exit_code]
cli_error() {
    local message="$1"
    local exit_code="${2:-1}"
    echo -e "${RED}错误: $message${NC}" >&2
    exit "$exit_code"
}

# 显示警告信息
# Usage: cli_warn <message>
cli_warn() {
    local message="$1"
    echo -e "${YELLOW}警告: $message${NC}" >&2
}

# 显示详细信息 (verbose 模式)
# Usage: cli_verbose <message>
cli_verbose() {
    if [[ "${CLI_VERBOSE:-0}" == "1" ]]; then
        local message="$1"
        echo -e "${CYAN}[verbose] $message${NC}" >&2
    fi
}

# 显示调试信息 (debug 模式)
# Usage: cli_debug <message>
cli_debug() {
    if [[ "${CLI_DEBUG:-0}" == "1" ]]; then
        local message="$1"
        echo -e "${PURPLE}[debug] $message${NC}" >&2
    fi
}

# ============================================================================
# 命令注册系统
# ============================================================================

# 注册一个命令
# Usage: cli_register_command <name> <handler> <description> [options]
#   name: 命令名称 (如: doing, stat, reset)
#   handler: 处理函数或脚本路径
#   description: 命令描述
#   options: 可选，命令支持的选项列表 (如: "--restart --module --job")
cli_register_command() {
    local name="$1"
    local handler="$2"
    local description="$3"
    local options="${4:-}"

    # 验证参数
    if [[ -z "$name" ]]; then
        cli_error "cli_register_command: 命令名称不能为空"
    fi
    if [[ -z "$handler" ]]; then
        cli_error "cli_register_command: 处理函数不能为空 ($name)"
    fi
    if [[ -z "$description" ]]; then
        cli_error "cli_register_command: 命令描述不能为空 ($name)"
    fi

    # 注册命令
    CLI_COMMAND_HANDLERS["$name"]="$handler"
    CLI_COMMAND_DESCRIPTIONS["$name"]="$description"
    CLI_COMMAND_OPTIONS["$name"]="$options"
    CLI_COMMAND_ORDER+=("$name")

    cli_debug "注册命令: $name -> $handler"
}

# 检查命令是否已注册
# Usage: cli_is_command_registered <name>
# Returns: 0=已注册, 1=未注册
cli_is_command_registered() {
    local name="$1"
    [[ -n "${CLI_COMMAND_HANDLERS[$name]:-}" ]]
}

# 获取命令的处理函数
# Usage: cli_get_handler <name>
cli_get_handler() {
    local name="$1"
    echo "${CLI_COMMAND_HANDLERS[$name]:-}"
}

# 获取命令的描述
# Usage: cli_get_description <name>
cli_get_description() {
    local name="$1"
    echo "${CLI_COMMAND_DESCRIPTIONS[$name]:-}"
}

# 获取命令的选项列表
# Usage: cli_get_options <name>
cli_get_options() {
    local name="$1"
    echo "${CLI_COMMAND_OPTIONS[$name]:-}"
}

# 获取所有已注册的命令列表
# Usage: cli_get_commands
cli_get_commands() {
    printf '%s\n' "${CLI_COMMAND_ORDER[@]}"
}

# ============================================================================
# 参数解析系统
# ============================================================================

# 清空解析结果
cli_parse_reset() {
    CLI_POSITIONAL_ARGS=()
    CLI_OPTION_ARGS=()
    CLI_OPTION_FLAGS=()
    CLI_PARSE_ERROR=0
}

# 解析命令行参数
# Usage: cli_parse_args <args...>
# Results stored in: CLI_POSITIONAL_ARGS, CLI_OPTION_ARGS, CLI_OPTION_FLAGS
cli_parse_args() {
    cli_parse_reset

    local args=("$@")
    local i=0
    local len=${#args[@]}

    cli_debug "开始解析参数: ${args[*]}"

    while [[ $i -lt $len ]]; do
        local arg="${args[$i]}"

        # 检查是否为选项
        if [[ "$arg" == --* ]]; then
            # 长选项 (--option)
            local option="$arg"
            local value=""

            # 检查是否有 = 赋值 (--option=value)
            if [[ "$option" == *=* ]]; then
                value="${option#*=}"
                option="${option%%=*}"
            fi

            # 检查是否需要取下一个参数作为值
            if [[ -z "$value" && $((i + 1)) -lt $len ]]; then
                local next_arg="${args[$((i + 1))]}"
                if [[ ! "$next_arg" == -* ]]; then
                    value="$next_arg"
                    i=$((i + 1))
                fi
            fi

            if [[ -n "$value" ]]; then
                CLI_OPTION_ARGS["$option"]="$value"
                cli_debug "解析选项: $option = $value"
            else
                CLI_OPTION_FLAGS+=("$option")
                cli_debug "解析标志: $option"
            fi

        elif [[ "$arg" == -* ]]; then
            # 短选项 (-a 或 -abc)
            local flags="${arg#-}"
            local j=0
            local flag_len=${#flags}

            while [[ $j -lt $flag_len ]]; do
                local flag="-${flags:$j:1}"

                # 检查是否需要取下一个参数作为值
                if [[ $((j + 1)) -eq $flag_len && $((i + 1)) -lt $len ]]; then
                    local next_arg="${args[$((i + 1))]}"
                    if [[ ! "$next_arg" == -* ]]; then
                        CLI_OPTION_ARGS["$flag"]="$next_arg"
                        cli_debug "解析短选项: $flag = $next_arg"
                        i=$((i + 1))
                    else
                        CLI_OPTION_FLAGS+=("$flag")
                        cli_debug "解析短标志: $flag"
                    fi
                else
                    CLI_OPTION_FLAGS+=("$flag")
                    cli_debug "解析短标志: $flag"
                fi

                j=$((j + 1))
            done

        else
            # 位置参数
            CLI_POSITIONAL_ARGS+=("$arg")
            cli_debug "解析位置参数: $arg"
        fi

        i=$((i + 1))
    done
}

# 检查是否设置了某个选项
# Usage: cli_has_option <option>
# Returns: 0=设置, 1=未设置
cli_has_option() {
    local option="$1"
    [[ -n "${CLI_OPTION_ARGS[$option]:-}" ]] && return 0
    for flag in "${CLI_OPTION_FLAGS[@]}"; do
        [[ "$flag" == "$option" ]] && return 0
    done
    return 1
}

# 获取选项的值
# Usage: cli_get_option_value <option> [default_value]
cli_get_option_value() {
    local option="$1"
    local default_value="${2:-}"
    echo "${CLI_OPTION_ARGS[$option]:-$default_value}"
}

# 获取位置参数
# Usage: cli_get_positional_args
cli_get_positional_args() {
    printf '%s\n' "${CLI_POSITIONAL_ARGS[@]}"
}

# 获取第 N 个位置参数 (从0开始)
# Usage: cli_get_positional_arg <index>
cli_get_positional_arg() {
    local index="$1"
    if [[ $index -lt ${#CLI_POSITIONAL_ARGS[@]} ]]; then
        echo "${CLI_POSITIONAL_ARGS[$index]}"
    fi
}

# 获取位置参数数量
# Usage: cli_get_positional_count
cli_get_positional_count() {
    echo ${#CLI_POSITIONAL_ARGS[@]}
}

# ============================================================================
# 命令路由系统
# ============================================================================

# 路由命令到对应的处理函数
# Usage: cli_route <command> [args...]
cli_route() {
    local command="${1:-}"
    shift || true

    # 如果没有指定命令，显示帮助
    if [[ -z "$command" ]]; then
        cli_show_global_help
        return 0
    fi

    cli_debug "路由命令: $command"

    # 检查命令是否已注册
    if ! cli_is_command_registered "$command"; then
        # 检查是否为特殊命令
        case "$command" in
            help|--help|-h)
                cli_show_global_help
                return 0
                ;;
            version|--version|-v)
                cli_show_version
                return 0
                ;;
            *)
                cli_error "未知命令 '$command'。运行 'morty help' 查看可用命令。" 2
                ;;
        esac
    fi

    # 执行命令
    cli_execute "$command" "$@"
}

# ============================================================================
# 命令执行系统
# ============================================================================

# 执行命令
# Usage: cli_execute <command> [args...]
cli_execute() {
    local command="$1"
    shift

    local handler
    handler=$(cli_get_handler "$command")

    cli_debug "执行命令: $command -> $handler"

    # 检查处理函数类型
    if [[ -f "$handler" ]]; then
        # 处理函数是脚本文件路径
        if [[ -x "$handler" ]]; then
            cli_verbose "执行脚本: $handler $*"
            exec "$handler" "$@"
        else
            cli_error "处理脚本不可执行: $handler"
        fi
    elif type "$handler" &>/dev/null; then
        # 处理函数是当前脚本中的函数
        cli_verbose "调用函数: $handler $*"
        "$handler" "$@"
    else
        cli_error "找不到处理函数: $handler"
    fi
}

# ============================================================================
# 帮助系统
# ============================================================================

# 显示全局帮助
# Usage: cli_show_global_help
cli_show_global_help() {
    cat << EOF
Morty ${VERSION}
上下文优先的AI Coding Agent 编排框架

用法: morty <command> [options]

命令:
EOF

    # 计算最大命令长度用于对齐
    local max_len=0
    for cmd in "${CLI_COMMAND_ORDER[@]}"; do
        local len=${#cmd}
        [[ $len -gt $max_len ]] && max_len=$len
    done

    # 显示命令列表
    for cmd in "${CLI_COMMAND_ORDER[@]}"; do
        local desc
        desc=$(cli_get_description "$cmd")
        printf "    %-${max_len}s    %s\n" "$cmd" "$desc"
    done

    cat << EOF

其他选项:
    help [command]          显示帮助信息
    version                 显示版本信息
    --verbose               显示详细执行过程
    --debug                 显示调试信息

使用 'morty help <command>' 查看特定命令的详细帮助。

示例:
    morty doing                     # 执行下一个未完成的 Job
    morty doing --restart           # 完全重置，从第一个 Job 开始
    morty doing --module config     # 仅执行 config 模块的 Job
    morty stat                      # 显示监控大盘
    morty stat -w                   # 进入监控模式
    morty reset -l                  # 显示循环提交历史
    morty reset -c abc123           # 回滚到指定提交

EOF
}

# 显示特定命令的帮助
# Usage: cli_show_command_help <command>
cli_show_command_help() {
    local command="$1"

    if [[ -z "$command" ]]; then
        cli_show_global_help
        return 0
    fi

    if ! cli_is_command_registered "$command"; then
        cli_error "未知命令: $command"
    fi

    local desc
    local options
    desc=$(cli_get_description "$command")
    options=$(cli_get_options "$command")

    echo ""
    echo "morty $command - $desc"
    echo ""
    echo "用法:"
    echo "  morty $command [options]"
    echo ""

    if [[ -n "$options" ]]; then
        echo "选项:"
        case "$command" in
            doing)
                echo "  --restart                 重置模式，重置 Job 状态但不重置 git"
                echo "  --module <name>           指定模块"
                echo "  --job <name>              指定 Job（必须与 --module 一起使用）"
                echo ""
                echo "说明:"
                echo "  - Job 是 AI coding agent 执行的最小任务单元"
                echo "  - Task 是 agent 内部 todo list 的最小执行单元"
                echo "  - 每次 doing 执行一个 Job 后退出（单循环模式）"
                echo "  - --restart 仅重置 status.json，保留 git 历史和工作变更"
                echo ""
                echo "示例:"
                echo "  morty doing                     # 执行下一个未完成的 Job"
                echo "  morty doing --module config     # 仅执行 config 模块的下一个 Job"
                echo "  morty doing --module config --job job_1    # 执行指定 Job"
                echo "  morty doing --restart           # 完全重置，从第一个 Job 开始"
                echo "  morty doing --restart --module config      # 重置并执行 config 模块"
                ;;
            stat)
                echo "  -t                        表格形式输出（默认）"
                echo "  -w                        监控模式，原地刷新（默认60s）"
                echo ""
                echo "说明:"
                echo "  显示信息包括："
                echo "  - 当前正在执行的模块和 Job"
                echo "  - 上一个 Job 的完成摘要"
                echo "  - 当前 Job loop 循环中需要 debug 的问题"
                echo "  - 整体 doing 的完成进度"
                echo "  - 当前 Job 运行的累计时间"
                echo ""
                echo "  默认每60秒自动刷新一次。"
                echo ""
                echo "示例:"
                echo "  morty stat                      # 显示监控大盘"
                echo "  morty stat -t                   # 表格形式输出"
                echo "  morty stat -w                   # 监控模式，持续刷新"
                ;;
            reset)
                echo "  -l [N]                    显示最近 N 次循环提交（默认10）"
                echo "  -c <commit_id>            回滚到指定提交"
                echo ""
                echo "说明:"
                echo "  -l 选项以表格形式输出，包含 CommitID、Message、Time"
                echo "  -c 选项会提示确认，回滚后当前 Job 状态将重置"
                echo ""
                echo "示例:"
                echo "  morty reset -l                  # 显示最近10次循环提交"
                echo "  morty reset -l 5                # 显示最近5次循环提交"
                echo "  morty reset -c abc1234          # 回滚到指定 commit"
                ;;
            *)
                echo "  $options"
                ;;
        esac
    fi

    echo ""
}

# 显示版本信息
# Usage: cli_show_version
cli_show_version() {
    echo "mort ${VERSION}"
    echo "上下文优先的AI Coding Agent 编排框架"
}

# ============================================================================
# 内置命令处理函数
# ============================================================================

# help 命令处理
handler_help() {
    cli_parse_args "$@"
    local subcommand
    subcommand=$(cli_get_positional_arg 0)

    if [[ -n "$subcommand" ]]; then
        cli_show_command_help "$subcommand"
    else
        cli_show_global_help
    fi
}

# version 命令处理
handler_version() {
    cli_show_version
}

# ============================================================================
# 系统初始化和命令注册
# ============================================================================

# 初始化命令注册表
cli_init_commands() {
    cli_debug "初始化命令注册表..."

    # 注册 doing 命令
    cli_register_command \
        "doing" \
        "$MORTY_HOME/morty_doing.sh" \
        "执行开发计划" \
        "--restart --module --job"

    # 注册 stat 命令
    cli_register_command \
        "stat" \
        "handler_stat" \
        "显示执行状态和进度（监控大盘）" \
        "-t -w"

    # 注册 reset 命令
    cli_register_command \
        "reset" \
        "$MORTY_HOME/morty_reset.sh" \
        "版本管理和回滚" \
        "-l -c"

    # 注册 version 命令 (内置)
    cli_register_command \
        "version" \
        "handler_version" \
        "显示版本信息" \
        ""

    # 注册 help 命令 (内置)
    cli_register_command \
        "help" \
        "handler_help" \
        "显示帮助信息" \
        ""

    cli_debug "命令注册完成，共注册 ${#CLI_COMMAND_ORDER[@]} 个命令"
}

# 检查前置依赖
cli_check_dependencies() {
    cli_debug "检查依赖..."

    # 检查 MORTY_HOME
    if [[ ! -d "$MORTY_HOME" ]]; then
        # 尝试使用脚本所在目录
        local script_dir
        script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
        if [[ -f "$script_dir/morty_doing.sh" ]]; then
            MORTY_HOME="$script_dir"
            cli_debug "设置 MORTY_HOME=$MORTY_HOME"
        else
            cli_warn "MORTY_HOME 目录不存在: $MORTY_HOME"
        fi
    fi

    # 检查必需的脚本
    local required_scripts=("morty_doing.sh" "morty_reset.sh")
    for script in "${required_scripts[@]}"; do
        if [[ ! -f "$MORTY_HOME/$script" ]]; then
            cli_warn "缺少必需脚本: $MORTY_HOME/$script"
        fi
    done
}

# stat 命令处理函数
handler_stat() {
    cli_parse_args "$@"

    # 检查 -w 监控模式
    if cli_has_option "-w"; then
        cli_verbose "进入监控模式"
        exec "$MORTY_HOME/morty_stat.sh" -w
    else
        # 默认表格输出
        exec "$MORTY_HOME/morty_stat.sh" -t
    fi
}

# ============================================================================
# 主入口
# ============================================================================

main() {
    # 解析全局选项
    local remaining_args=()
    for arg in "$@"; do
        case "$arg" in
            --verbose)
                CLI_VERBOSE=1
                ;;
            --debug)
                CLI_DEBUG=1
                ;;
            *)
                remaining_args+=("$arg")
                ;;
        esac
    done

    cli_debug "剩余参数: ${remaining_args[*]}"

    # 初始化
    cli_check_dependencies
    cli_init_commands

    # 路由命令
    if [[ ${#remaining_args[@]} -eq 0 ]]; then
        cli_show_global_help
        exit 0
    fi

    cli_route "${remaining_args[@]}"
}

# 运行主函数
main "$@"
