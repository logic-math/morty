#!/bin/bash
# Morty - 上下文优先的AI Coding Agent 编排框架
# 统一命令接口 - 主命令脚本
#
# 文件名: morty
# 位置: $MORTY_HOME/morty 或 /usr/local/bin/morty

set -o pipefail

# ============================================================================
# 全局变量
# ============================================================================

VERSION="2.0.0"
MORTY_HOME="${MORTY_HOME:-$HOME/.morty}"
export MORTY_HOME
MORTY_PROJECT_ROOT="${MORTY_PROJECT_ROOT:-}"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# ============================================================================
# 加载库文件
# ============================================================================

# 确定脚本所在目录（使用 readlink -f 解析符号链接）
MORTY_SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"

# 加载库文件
source "${MORTY_SCRIPT_DIR}/lib/cli_parse_args.sh"
source "${MORTY_SCRIPT_DIR}/lib/cli_register_command.sh"
source "${MORTY_SCRIPT_DIR}/lib/cli_route.sh"
source "${MORTY_SCRIPT_DIR}/lib/cli_execute.sh"

# ============================================================================
# 错误处理和日志
# ============================================================================

# 显示错误信息并退出
# Usage: cli_error <message> [exit_code]
cli_error() {
    local message="$1"
    local exit_code="${2:-1}"
    echo -e "${RED}错误: $message${NC}" >&2
    exit "$exit_code"
}

# 显示警告信息
# Usage: cli_warn <message>
cli_warn() {
    local message="$1"
    echo -e "${YELLOW}警告: $message${NC}" >&2
}

# 显示详细信息 (verbose 模式)
# Usage: cli_verbose <message>
cli_verbose() {
    if [[ "${CLI_VERBOSE:-0}" == "1" ]]; then
        local message="$1"
        echo -e "${CYAN}[verbose] $message${NC}" >&2
    fi
}

# 设置调试输出函数供库使用
CLI_DEBUG_FN="cli_debug"

# 显示调试信息 (debug 模式)
# Usage: cli_debug <message>
cli_debug() {
    if [[ "${CLI_DEBUG:-0}" == "1" ]]; then
        local message="$1"
        echo -e "${PURPLE}[debug] $message${NC}" >&2
    fi
}

# ============================================================================
# 命令注册系统 (使用 lib/cli_register_command.sh)
# ============================================================================

# 注: 核心命令注册函数已从 lib/cli_register_command.sh 加载
# 以下是对库函数的包装，保持一致的错误处理风格

# 注册命令（带错误处理包装）
cli_register_command() {
    local name="$1"
    local handler="$2"
    local description="$3"
    local options="${4:-}"

    if [[ -z "$name" || -z "$handler" || -z "$description" ]]; then
        cli_error "cli_register_command: 参数不能为空"
    fi

    # 调用库函数
    if ! _cli_register_command_impl "$name" "$handler" "$description" "$options"; then
        cli_error "注册命令失败: $name"
    fi

    cli_debug "注册命令: $name -> $handler"
}

# 内部实现调用库函数
_cli_register_command_impl() {
    # 直接使用库中的实现
    local name="${1:-}"
    local handler="${2:-}"
    local description="${3:-}"
    local options="${4:-}"

    if [[ -z "$name" ]]; then
        echo "错误: cli_register_command: 命令名称不能为空" >&2
        return 1
    fi

    if [[ -z "$handler" ]]; then
        echo "错误: cli_register_command: 处理函数不能为空 ($name)" >&2
        return 1
    fi

    if [[ -z "$description" ]]; then
        echo "错误: cli_register_command: 命令描述不能为空 ($name)" >&2
        return 1
    fi

    # 检查命令是否已注册
    if [[ -n "${_CLI_COMMAND_HANDLERS[$name]:-}" ]]; then
        echo "警告: 命令 '$name' 已存在，将被覆盖" >&2
    fi

    # 注册命令
    _CLI_COMMAND_HANDLERS["$name"]="$handler"
    _CLI_COMMAND_DESCRIPTIONS["$name"]="$description"
    _CLI_COMMAND_OPTIONS["$name"]="$options"

    # 维护命令顺序
    local found=false
    for cmd in "${_CLI_COMMAND_ORDER[@]}"; do
        if [[ "$cmd" == "$name" ]]; then
            found=true
            break
        fi
    done
    [[ "$found" == "false" ]] && _CLI_COMMAND_ORDER+=("$name")

    return 0
}

# ============================================================================
# 参数解析系统 (使用 lib/cli_parse_args.sh)
# ============================================================================

# 注: 所有参数解析函数已从 lib/cli_parse_args.sh 加载
# CLI_POSITIONAL_ARGS, CLI_OPTION_ARGS, CLI_OPTION_FLAGS 在库中定义

# ============================================================================
# 命令路由系统 (使用 lib/cli_route.sh 和 lib/cli_execute.sh)
# ============================================================================

# 注: 路由和执行函数已从库文件加载

# ============================================================================
# 命令执行系统
# ============================================================================

# 执行命令
# Usage: cli_execute <command> [args...]
cli_execute() {
    local command="$1"
    shift

    local handler
    handler=$(cli_get_handler "$command")

    cli_debug "执行命令: $command -> $handler"

    # 检查处理函数类型
    if [[ -f "$handler" ]]; then
        # 处理函数是脚本文件路径
        if [[ -x "$handler" ]]; then
            cli_verbose "执行脚本: $handler $*"
            exec "$handler" "$@"
        else
            cli_error "处理脚本不可执行: $handler"
        fi
    elif type "$handler" &>/dev/null; then
        # 处理函数是当前脚本中的函数
        cli_verbose "调用函数: $handler $*"
        "$handler" "$@"
    else
        cli_error "找不到处理函数: $handler"
    fi
}

# ============================================================================
# 帮助系统
# ============================================================================

# 显示全局帮助
# Usage: cli_show_global_help
cli_show_global_help() {
    cat << EOF
Morty ${VERSION}
上下文优先的AI Coding Agent 编排框架

用法: morty <command> [options]

命令:
EOF

    # 计算最大命令长度用于对齐
    local max_len=0
    for cmd in "${_CLI_COMMAND_ORDER[@]}"; do
        local len=${#cmd}
        [[ $len -gt $max_len ]] && max_len=$len
    done

    # 显示命令列表
    for cmd in "${_CLI_COMMAND_ORDER[@]}"; do
        local desc
        desc=$(cli_get_description "$cmd")
        printf "    %-${max_len}s    %s\n" "$cmd" "$desc"
    done

    cat << EOF

其他选项:
    help [command]          显示帮助信息
    version                 显示版本信息
    --verbose               显示详细执行过程
    --debug                 显示调试信息

使用 'morty help <command>' 查看特定命令的详细帮助。

示例:
    morty doing                     # 执行下一个未完成的 Job
    morty doing --restart           # 完全重置，从第一个 Job 开始
    morty doing --module config     # 仅执行 config 模块的 Job
    morty stat                      # 显示监控大盘
    morty stat -w                   # 进入监控模式
    morty reset -l                  # 显示循环提交历史
    morty reset -c abc123           # 回滚到指定提交

EOF
}

# 显示特定命令的帮助
# Usage: cli_show_command_help <command>
cli_show_command_help() {
    local command="$1"

    if [[ -z "$command" ]]; then
        cli_show_global_help
        return 0
    fi

    if ! cli_is_command_registered "$command"; then
        cli_error "未知命令: $command"
    fi

    local desc
    local options
    desc=$(cli_get_description "$command")
    options=$(cli_get_options "$command")

    echo ""
    echo "morty $command - $desc"
    echo ""
    echo "用法:"
    echo "  morty $command [options]"
    echo ""

    if [[ -n "$options" ]]; then
        echo "选项:"
        case "$command" in
            doing)
                echo "  --restart                 重置模式，重置 Job 状态但不重置 git"
                echo "  --module <name>           指定模块"
                echo "  --job <name>              指定 Job（必须与 --module 一起使用）"
                echo ""
                echo "说明:"
                echo "  - Job 是 AI coding agent 执行的最小任务单元"
                echo "  - Task 是 agent 内部 todo list 的最小执行单元"
                echo "  - 每次 doing 执行一个 Job 后退出（单循环模式）"
                echo "  - --restart 仅重置 status.json，保留 git 历史和工作变更"
                echo ""
                echo "示例:"
                echo "  morty doing                     # 执行下一个未完成的 Job"
                echo "  morty doing --module config     # 仅执行 config 模块的下一个 Job"
                echo "  morty doing --module config --job job_1    # 执行指定 Job"
                echo "  morty doing --restart           # 完全重置，从第一个 Job 开始"
                echo "  morty doing --restart --module config      # 重置并执行 config 模块"
                ;;
            stat)
                echo "  -t                        表格形式输出（默认）"
                echo "  -w                        监控模式，原地刷新（默认60s）"
                echo ""
                echo "说明:"
                echo "  显示信息包括："
                echo "  - 当前正在执行的模块和 Job"
                echo "  - 上一个 Job 的完成摘要"
                echo "  - 当前 Job loop 循环中需要 debug 的问题"
                echo "  - 整体 doing 的完成进度"
                echo "  - 当前 Job 运行的累计时间"
                echo ""
                echo "  默认每60秒自动刷新一次。"
                echo ""
                echo "示例:"
                echo "  morty stat                      # 显示监控大盘"
                echo "  morty stat -t                   # 表格形式输出"
                echo "  morty stat -w                   # 监控模式，持续刷新"
                ;;
            reset)
                echo "  -l [N]                    显示最近 N 次循环提交（默认10）"
                echo "  -c <commit_id>            回滚到指定提交"
                echo ""
                echo "说明:"
                echo "  -l 选项以表格形式输出，包含 CommitID、Message、Time"
                echo "  -c 选项会提示确认，回滚后当前 Job 状态将重置"
                echo ""
                echo "示例:"
                echo "  morty reset -l                  # 显示最近10次循环提交"
                echo "  morty reset -l 5                # 显示最近5次循环提交"
                echo "  morty reset -c abc1234          # 回滚到指定 commit"
                ;;
            *)
                echo "  $options"
                ;;
        esac
    fi

    echo ""
}

# 显示版本信息
# Usage: cli_show_version
cli_show_version() {
    echo "mort ${VERSION}"
    echo "上下文优先的AI Coding Agent 编排框架"
}

# ============================================================================
# 内置命令处理函数
# ============================================================================

# help 命令处理
handler_help() {
    cli_parse_args "$@"
    local subcommand
    subcommand=$(cli_get_positional_arg 0)

    if [[ -n "$subcommand" ]]; then
        cli_show_command_help "$subcommand"
    else
        cli_show_global_help
    fi
}

# version 命令处理
handler_version() {
    cli_show_version
}

# plan 命令处理
handler_plan() {
    # 加载依赖库
    source "$MORTY_SCRIPT_DIR/lib/common.sh"
    source "$MORTY_SCRIPT_DIR/lib/config.sh"

    # 加载配置
    config_load 2>/dev/null || true

    # 从配置获取 AI CLI 命令，默认为 claude
    local AI_CLI
    AI_CLI=$(config_get "cli.command" "claude")

    # 配置
    local PLAN_PROMPT="$MORTY_SCRIPT_DIR/../prompts/plan.md"
    local MORTY_DIR=".morty"
    local PLAN_DIR="$MORTY_DIR/plan"
    local RESEARCH_DIR="$MORTY_DIR/research"

    # 解析参数
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                cat << 'EOF'
Morty Plan 模式 - 基于研究结果创建 TDD 开发计划

用法: morty plan [选项]

选项:
    -h, --help          显示帮助信息

描述:
    Plan 模式基于 research 模式的研究结果，创建分层的 TDD 开发计划。

    工作流程:
    1. 检查 .morty/research/ 目录下的研究结果
    2. 启动交互式 Claude Code 会话
    3. 根据需要读取相关 research 文件作为事实性信息
    4. 设计系统架构，划分功能模块
    5. 为每个模块创建 [模块名].md 文件（含 Jobs + 验证器）
    6. 创建 [生产测试].md 端到端测试计划
    7. 生成 plan/README.md 索引文件

    输出结构:
    .morty/plan/
    ├── README.md           # Plan 索引
    ├── [模块A].md          # 功能模块 A 计划（含 Jobs + 验证器）
    ├── [模块B].md          # 功能模块 B 计划
    └── [生产测试].md       # 端到端测试计划

示例:
    morty plan              # 启动 Plan 模式

前置条件:
    - 必须先运行 morty research 生成研究结果
    - .morty/research/ 目录必须存在且非空

EOF
                return 0
                ;;
            *)
                echo -e "${RED}错误: 未知参数: $1${NC}" >&2
                return 1
                ;;
        esac
    done

    # 检查提示词文件
    if [[ ! -f "$PLAN_PROMPT" ]]; then
        echo -e "${RED}错误: Plan 模式提示词未找到: $PLAN_PROMPT${NC}" >&2
        return 1
    fi

    # 检查前置条件：.morty 目录存在
    if [[ ! -d "$MORTY_DIR" ]]; then
        echo -e "${RED}错误: .morty/ 目录不存在${NC}" >&2
        echo "请先运行 morty research 进行项目研究" >&2
        return 1
    fi

    # 检查前置条件：research 目录存在且有内容
    if [[ ! -d "$RESEARCH_DIR" ]]; then
        echo -e "${RED}错误: .morty/research/ 目录不存在${NC}" >&2
        echo "请先运行 morty research 生成研究结果" >&2
        return 1
    fi

    # 检查 research 目录是否有 .md 文件
    local RESEARCH_FILES
    RESEARCH_FILES=$(find "$RESEARCH_DIR" -name "*.md" -type f 2>/dev/null || true)
    if [[ -z "$RESEARCH_FILES" ]]; then
        echo -e "${RED}错误: .morty/research/ 目录中没有 .md 文件${NC}" >&2
        echo "请先运行 morty research 生成研究结果" >&2
        return 1
    fi

    # 创建 plan 目录
    mkdir -p "$PLAN_DIR"

    log INFO "╔════════════════════════════════════════════════════════════╗"
    log INFO "║              MORTY PLAN 模式 - TDD 开发计划                ║"
    log INFO "╚════════════════════════════════════════════════════════════╝"
    log INFO ""

    # 统计 research 文件
    local RESEARCH_COUNT
    RESEARCH_COUNT=$(echo "$RESEARCH_FILES" | wc -l)
    log INFO "发现 $RESEARCH_COUNT 个研究文件:"
    while IFS= read -r file; do
        log INFO "  - $(basename "$file")"
    done <<< "$RESEARCH_FILES"
    log INFO ""

    # 构建可用研究文件列表（仅文件名，不加载内容）
    local RESEARCH_FILE_LIST=""
    while IFS= read -r file; do
        if [[ -f "$file" ]]; then
            RESEARCH_FILE_LIST="${RESEARCH_FILE_LIST}- \`$file\`\n"
        fi
    done <<< "$RESEARCH_FILES"

    # 创建临时提示词文件（直接写入，避免 shell 解析）
    local PROMPT_FILE
    PROMPT_FILE=$(mktemp -t morty-plan-prompt.XXXXXX)

    # 写入提示词头部（从文件读取）
    cat "$PLAN_PROMPT" >> "$PROMPT_FILE"

    # 写入动态部分
    cat >> "$PROMPT_FILE" << EOF

---

# 当前运行状态

**工作目录**: $(pwd)
**Plan 目录**: $PLAN_DIR/
**Research 目录**: $RESEARCH_DIR/
**研究文件数量**: $RESEARCH_COUNT

---

# 可用研究文件

以下研究文件包含事实性信息，请根据需要使用 Read 工具读取：

$RESEARCH_FILE_LIST

**说明**:
- 以上文件是 Research 模式生成的研究结果
- 请根据架构设计需要，选择性读取相关文件
- 这些文件包含目录结构、核心功能、处理流程等事实性信息

---

# Plan 目录结构

Plan 模式将在 $PLAN_DIR/ 目录下创建以下文件：
- README.md - Plan 索引
- [模块名].md - 各功能模块计划
- [生产测试].md - 端到端测试计划

---

开始对话！请基于 Research 文件中的事实性信息进行架构设计，划分功能模块，创建 Plan 文件。
EOF

    log INFO "启动 Claude Code 交互式会话..."
    log INFO ""
    log INFO "Plan 模式将："
    log INFO "  1. 根据需要读取 research 文件获取事实性信息"
    log INFO "  2. 设计系统架构，划分功能模块"
    log INFO "  3. 为每个模块创建 [模块名].md 文件"
    log INFO "  4. 创建 [生产测试].md 端到端测试计划"
    log INFO "  5. 生成 README.md 索引"
    log INFO ""

    log INFO "提示词已写入临时文件: $PROMPT_FILE"
    log INFO ""

    # 以 Plan 模式调用 ai_cli（交互式）
    # 使用 stdin 重定向传递提示词，保持交互式运行
    "$AI_CLI" --permission-mode plan < "$PROMPT_FILE"

    local CLAUDE_EXIT_CODE=$?

    # 清理临时文件
    rm -f "$PROMPT_FILE"

    log INFO ""
    log INFO "Claude Code 退出码: $CLAUDE_EXIT_CODE"
    log INFO ""

    # 检查 plan 目录是否生成内容
    if [[ -d "$PLAN_DIR" ]]; then
        local PLAN_FILES
        PLAN_FILES=$(find "$PLAN_DIR" -name "*.md" -type f 2>/dev/null || true)
        if [[ -n "$PLAN_FILES" ]]; then
            local PLAN_COUNT
            PLAN_COUNT=$(echo "$PLAN_FILES" | wc -l)
            log SUCCESS "Plan 文件已生成: $PLAN_COUNT 个"
            while IFS= read -r file; do
                log INFO "  - $(basename "$file")"
            done <<< "$PLAN_FILES"
            log INFO ""
            log INFO "下一步:"
            log INFO "  运行 'morty doing' 开始分层 TDD 开发"
        else
            log WARN "Plan 目录为空，可能没有生成文件"
        fi
    else
        log WARN "Plan 目录未创建"
    fi

    log INFO ""
    log SUCCESS "Plan 模式会话结束"

    return $CLAUDE_EXIT_CODE
}

# ============================================================================
# 系统初始化和命令注册
# ============================================================================

# 初始化命令注册表
cli_init_commands() {
    cli_debug "初始化命令注册表..."

    # 注册 research 命令
    cli_register_command \
        "research" \
        "$MORTY_HOME/bin/morty_research.sh" \
        "启动研究流程" \
        ""

    # 注册 plan 命令
    cli_register_command \
        "plan" \
        "handler_plan" \
        "基于研究结果创建 TDD 开发计划" \
        "-h --help"

    # 注册 doing 命令
    cli_register_command \
        "doing" \
        "$MORTY_HOME/bin/morty_doing.sh" \
        "执行开发计划" \
        "--restart --module --job"

    # 注册 stat 命令
    cli_register_command \
        "stat" \
        "handler_stat" \
        "显示执行状态和进度（监控大盘）" \
        "-t -w"

    # 注册 reset 命令
    cli_register_command \
        "reset" \
        "$MORTY_HOME/bin/morty_reset.sh" \
        "版本管理和回滚" \
        "-l -c"

    # 注册 version 命令 (内置)
    cli_register_command \
        "version" \
        "handler_version" \
        "显示版本信息" \
        ""

    # 注册 help 命令 (内置)
    cli_register_command \
        "help" \
        "handler_help" \
        "显示帮助信息" \
        ""

    cli_debug "命令注册完成，共注册 ${#_CLI_COMMAND_ORDER[@]} 个命令"
}

# 检查前置依赖
cli_check_dependencies() {
    cli_debug "检查依赖..."

    # 检查 MORTY_HOME
    if [[ ! -d "$MORTY_HOME" ]]; then
        # 尝试使用脚本所在目录
        local script_dir
        script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
        if [[ -f "$script_dir/morty_doing.sh" ]]; then
            MORTY_HOME="$script_dir"
            cli_debug "设置 MORTY_HOME=$MORTY_HOME"
        else
            cli_warn "MORTY_HOME 目录不存在: $MORTY_HOME"
        fi
    fi

    # 检查必需的脚本
    local required_scripts=("morty_doing.sh" "morty_reset.sh")
    for script in "${required_scripts[@]}"; do
        if [[ ! -f "$MORTY_HOME/bin/$script" ]]; then
            cli_warn "缺少必需脚本: $MORTY_HOME/bin/$script"
        fi
    done
}

# stat 命令处理函数
handler_stat() {
    cli_parse_args "$@"

    # 检查 -w 监控模式
    if cli_has_option "-w"; then
        cli_verbose "进入监控模式"
        exec "$MORTY_HOME/bin/morty_stat.sh" -w
    else
        # 默认表格输出
        exec "$MORTY_HOME/bin/morty_stat.sh" -t
    fi
}

# ============================================================================
# 主入口
# ============================================================================

main() {
    # 解析全局选项
    local remaining_args=()
    for arg in "$@"; do
        case "$arg" in
            --verbose)
                CLI_VERBOSE=1
                ;;
            --debug)
                CLI_DEBUG=1
                ;;
            *)
                remaining_args+=("$arg")
                ;;
        esac
    done

    cli_debug "剩余参数: ${remaining_args[*]}"

    # 初始化
    cli_check_dependencies
    cli_init_commands

    # 路由命令
    if [[ ${#remaining_args[@]} -eq 0 ]]; then
        cli_show_global_help
        exit 0
    fi

    cli_route "${remaining_args[@]}"
}

# 运行主函数
main "$@"
