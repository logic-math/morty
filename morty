#!/bin/bash
# Morty - 上下文优先的AI Coding Agent 编排框架
# 统一命令接口 - 主命令脚本
#
# 文件名: morty
# 位置: $MORTY_HOME/morty 或 /usr/local/bin/morty

set -o pipefail

# ============================================================================
# 全局变量
# ============================================================================

VERSION="2.0.0"
MORTY_HOME="${MORTY_HOME:-$HOME/.morty}"
MORTY_PROJECT_ROOT="${MORTY_PROJECT_ROOT:-}"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# ============================================================================
# 加载库文件
# ============================================================================

# 确定脚本所在目录
MORTY_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# 加载库文件
source "${MORTY_SCRIPT_DIR}/lib/cli_parse_args.sh"
source "${MORTY_SCRIPT_DIR}/lib/cli_register_command.sh"
source "${MORTY_SCRIPT_DIR}/lib/cli_route.sh"
source "${MORTY_SCRIPT_DIR}/lib/cli_execute.sh"

# ============================================================================
# 错误处理和日志
# ============================================================================

# 显示错误信息并退出
# Usage: cli_error <message> [exit_code]
cli_error() {
    local message="$1"
    local exit_code="${2:-1}"
    echo -e "${RED}错误: $message${NC}" >&2
    exit "$exit_code"
}

# 显示警告信息
# Usage: cli_warn <message>
cli_warn() {
    local message="$1"
    echo -e "${YELLOW}警告: $message${NC}" >&2
}

# 显示详细信息 (verbose 模式)
# Usage: cli_verbose <message>
cli_verbose() {
    if [[ "${CLI_VERBOSE:-0}" == "1" ]]; then
        local message="$1"
        echo -e "${CYAN}[verbose] $message${NC}" >&2
    fi
}

# 设置调试输出函数供库使用
CLI_DEBUG_FN="cli_debug"

# 显示调试信息 (debug 模式)
# Usage: cli_debug <message>
cli_debug() {
    if [[ "${CLI_DEBUG:-0}" == "1" ]]; then
        local message="$1"
        echo -e "${PURPLE}[debug] $message${NC}" >&2
    fi
}

# ============================================================================
# 命令注册系统 (使用 lib/cli_register_command.sh)
# ============================================================================

# 注: 核心命令注册函数已从 lib/cli_register_command.sh 加载
# 以下是对库函数的包装，保持一致的错误处理风格

# 注册命令（带错误处理包装）
cli_register_command() {
    local name="$1"
    local handler="$2"
    local description="$3"
    local options="${4:-}"

    if [[ -z "$name" || -z "$handler" || -z "$description" ]]; then
        cli_error "cli_register_command: 参数不能为空"
    fi

    # 调用库函数
    if ! _cli_register_command_impl "$name" "$handler" "$description" "$options"; then
        cli_error "注册命令失败: $name"
    fi

    cli_debug "注册命令: $name -> $handler"
}

# 内部实现调用库函数
_cli_register_command_impl() {
    # 直接使用库中的实现
    local name="${1:-}"
    local handler="${2:-}"
    local description="${3:-}"
    local options="${4:-}"

    if [[ -z "$name" ]]; then
        echo "错误: cli_register_command: 命令名称不能为空" >&2
        return 1
    fi

    if [[ -z "$handler" ]]; then
        echo "错误: cli_register_command: 处理函数不能为空 ($name)" >&2
        return 1
    fi

    if [[ -z "$description" ]]; then
        echo "错误: cli_register_command: 命令描述不能为空 ($name)" >&2
        return 1
    fi

    # 检查命令是否已注册
    if [[ -n "${_CLI_COMMAND_HANDLERS[$name]:-}" ]]; then
        echo "警告: 命令 '$name' 已存在，将被覆盖" >&2
    fi

    # 注册命令
    _CLI_COMMAND_HANDLERS["$name"]="$handler"
    _CLI_COMMAND_DESCRIPTIONS["$name"]="$description"
    _CLI_COMMAND_OPTIONS["$name"]="$options"

    # 维护命令顺序
    local found=false
    for cmd in "${_CLI_COMMAND_ORDER[@]}"; do
        if [[ "$cmd" == "$name" ]]; then
            found=true
            break
        fi
    done
    [[ "$found" == "false" ]] && _CLI_COMMAND_ORDER+=("$name")

    return 0
}

# ============================================================================
# 参数解析系统 (使用 lib/cli_parse_args.sh)
# ============================================================================

# 注: 所有参数解析函数已从 lib/cli_parse_args.sh 加载
# CLI_POSITIONAL_ARGS, CLI_OPTION_ARGS, CLI_OPTION_FLAGS 在库中定义

# ============================================================================
# 命令路由系统 (使用 lib/cli_route.sh 和 lib/cli_execute.sh)
# ============================================================================

# 注: 路由和执行函数已从库文件加载

# ============================================================================
# 命令执行系统
# ============================================================================

# 执行命令
# Usage: cli_execute <command> [args...]
cli_execute() {
    local command="$1"
    shift

    local handler
    handler=$(cli_get_handler "$command")

    cli_debug "执行命令: $command -> $handler"

    # 检查处理函数类型
    if [[ -f "$handler" ]]; then
        # 处理函数是脚本文件路径
        if [[ -x "$handler" ]]; then
            cli_verbose "执行脚本: $handler $*"
            exec "$handler" "$@"
        else
            cli_error "处理脚本不可执行: $handler"
        fi
    elif type "$handler" &>/dev/null; then
        # 处理函数是当前脚本中的函数
        cli_verbose "调用函数: $handler $*"
        "$handler" "$@"
    else
        cli_error "找不到处理函数: $handler"
    fi
}

# ============================================================================
# 帮助系统
# ============================================================================

# 显示全局帮助
# Usage: cli_show_global_help
cli_show_global_help() {
    cat << EOF
Morty ${VERSION}
上下文优先的AI Coding Agent 编排框架

用法: morty <command> [options]

命令:
EOF

    # 计算最大命令长度用于对齐
    local max_len=0
    for cmd in "${_CLI_COMMAND_ORDER[@]}"; do
        local len=${#cmd}
        [[ $len -gt $max_len ]] && max_len=$len
    done

    # 显示命令列表
    for cmd in "${_CLI_COMMAND_ORDER[@]}"; do
        local desc
        desc=$(cli_get_description "$cmd")
        printf "    %-${max_len}s    %s\n" "$cmd" "$desc"
    done

    cat << EOF

其他选项:
    help [command]          显示帮助信息
    version                 显示版本信息
    --verbose               显示详细执行过程
    --debug                 显示调试信息

使用 'morty help <command>' 查看特定命令的详细帮助。

示例:
    morty doing                     # 执行下一个未完成的 Job
    morty doing --restart           # 完全重置，从第一个 Job 开始
    morty doing --module config     # 仅执行 config 模块的 Job
    morty stat                      # 显示监控大盘
    morty stat -w                   # 进入监控模式
    morty reset -l                  # 显示循环提交历史
    morty reset -c abc123           # 回滚到指定提交

EOF
}

# 显示特定命令的帮助
# Usage: cli_show_command_help <command>
cli_show_command_help() {
    local command="$1"

    if [[ -z "$command" ]]; then
        cli_show_global_help
        return 0
    fi

    if ! cli_is_command_registered "$command"; then
        cli_error "未知命令: $command"
    fi

    local desc
    local options
    desc=$(cli_get_description "$command")
    options=$(cli_get_options "$command")

    echo ""
    echo "morty $command - $desc"
    echo ""
    echo "用法:"
    echo "  morty $command [options]"
    echo ""

    if [[ -n "$options" ]]; then
        echo "选项:"
        case "$command" in
            doing)
                echo "  --restart                 重置模式，重置 Job 状态但不重置 git"
                echo "  --module <name>           指定模块"
                echo "  --job <name>              指定 Job（必须与 --module 一起使用）"
                echo ""
                echo "说明:"
                echo "  - Job 是 AI coding agent 执行的最小任务单元"
                echo "  - Task 是 agent 内部 todo list 的最小执行单元"
                echo "  - 每次 doing 执行一个 Job 后退出（单循环模式）"
                echo "  - --restart 仅重置 status.json，保留 git 历史和工作变更"
                echo ""
                echo "示例:"
                echo "  morty doing                     # 执行下一个未完成的 Job"
                echo "  morty doing --module config     # 仅执行 config 模块的下一个 Job"
                echo "  morty doing --module config --job job_1    # 执行指定 Job"
                echo "  morty doing --restart           # 完全重置，从第一个 Job 开始"
                echo "  morty doing --restart --module config      # 重置并执行 config 模块"
                ;;
            stat)
                echo "  -t                        表格形式输出（默认）"
                echo "  -w                        监控模式，原地刷新（默认60s）"
                echo ""
                echo "说明:"
                echo "  显示信息包括："
                echo "  - 当前正在执行的模块和 Job"
                echo "  - 上一个 Job 的完成摘要"
                echo "  - 当前 Job loop 循环中需要 debug 的问题"
                echo "  - 整体 doing 的完成进度"
                echo "  - 当前 Job 运行的累计时间"
                echo ""
                echo "  默认每60秒自动刷新一次。"
                echo ""
                echo "示例:"
                echo "  morty stat                      # 显示监控大盘"
                echo "  morty stat -t                   # 表格形式输出"
                echo "  morty stat -w                   # 监控模式，持续刷新"
                ;;
            reset)
                echo "  -l [N]                    显示最近 N 次循环提交（默认10）"
                echo "  -c <commit_id>            回滚到指定提交"
                echo ""
                echo "说明:"
                echo "  -l 选项以表格形式输出，包含 CommitID、Message、Time"
                echo "  -c 选项会提示确认，回滚后当前 Job 状态将重置"
                echo ""
                echo "示例:"
                echo "  morty reset -l                  # 显示最近10次循环提交"
                echo "  morty reset -l 5                # 显示最近5次循环提交"
                echo "  morty reset -c abc1234          # 回滚到指定 commit"
                ;;
            *)
                echo "  $options"
                ;;
        esac
    fi

    echo ""
}

# 显示版本信息
# Usage: cli_show_version
cli_show_version() {
    echo "mort ${VERSION}"
    echo "上下文优先的AI Coding Agent 编排框架"
}

# ============================================================================
# 内置命令处理函数
# ============================================================================

# help 命令处理
handler_help() {
    cli_parse_args "$@"
    local subcommand
    subcommand=$(cli_get_positional_arg 0)

    if [[ -n "$subcommand" ]]; then
        cli_show_command_help "$subcommand"
    else
        cli_show_global_help
    fi
}

# version 命令处理
handler_version() {
    cli_show_version
}

# ============================================================================
# 系统初始化和命令注册
# ============================================================================

# 初始化命令注册表
cli_init_commands() {
    cli_debug "初始化命令注册表..."

    # 注册 doing 命令
    cli_register_command \
        "doing" \
        "$MORTY_HOME/morty_doing.sh" \
        "执行开发计划" \
        "--restart --module --job"

    # 注册 stat 命令
    cli_register_command \
        "stat" \
        "handler_stat" \
        "显示执行状态和进度（监控大盘）" \
        "-t -w"

    # 注册 reset 命令
    cli_register_command \
        "reset" \
        "$MORTY_HOME/morty_reset.sh" \
        "版本管理和回滚" \
        "-l -c"

    # 注册 version 命令 (内置)
    cli_register_command \
        "version" \
        "handler_version" \
        "显示版本信息" \
        ""

    # 注册 help 命令 (内置)
    cli_register_command \
        "help" \
        "handler_help" \
        "显示帮助信息" \
        ""

    cli_debug "命令注册完成，共注册 ${#_CLI_COMMAND_ORDER[@]} 个命令"
}

# 检查前置依赖
cli_check_dependencies() {
    cli_debug "检查依赖..."

    # 检查 MORTY_HOME
    if [[ ! -d "$MORTY_HOME" ]]; then
        # 尝试使用脚本所在目录
        local script_dir
        script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
        if [[ -f "$script_dir/morty_doing.sh" ]]; then
            MORTY_HOME="$script_dir"
            cli_debug "设置 MORTY_HOME=$MORTY_HOME"
        else
            cli_warn "MORTY_HOME 目录不存在: $MORTY_HOME"
        fi
    fi

    # 检查必需的脚本
    local required_scripts=("morty_doing.sh" "morty_reset.sh")
    for script in "${required_scripts[@]}"; do
        if [[ ! -f "$MORTY_HOME/$script" ]]; then
            cli_warn "缺少必需脚本: $MORTY_HOME/$script"
        fi
    done
}

# stat 命令处理函数
handler_stat() {
    cli_parse_args "$@"

    # 检查 -w 监控模式
    if cli_has_option "-w"; then
        cli_verbose "进入监控模式"
        exec "$MORTY_HOME/morty_stat.sh" -w
    else
        # 默认表格输出
        exec "$MORTY_HOME/morty_stat.sh" -t
    fi
}

# ============================================================================
# 主入口
# ============================================================================

main() {
    # 解析全局选项
    local remaining_args=()
    for arg in "$@"; do
        case "$arg" in
            --verbose)
                CLI_VERBOSE=1
                ;;
            --debug)
                CLI_DEBUG=1
                ;;
            *)
                remaining_args+=("$arg")
                ;;
        esac
    done

    cli_debug "剩余参数: ${remaining_args[*]}"

    # 初始化
    cli_check_dependencies
    cli_init_commands

    # 路由命令
    if [[ ${#remaining_args[@]} -eq 0 ]]; then
        cli_show_global_help
        exit 0
    fi

    cli_route "${remaining_args[@]}"
}

# 运行主函数
main "$@"
